<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="keywords" content="LLVM,Low Level Virtual Machine,C++,doxygen,API,documentation"/>
<meta name="description" content="C++ source code API documentation for LLVM."/>
<title>LLVM: llvm::MemoryObject Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head><body>
<p class="title">LLVM API Documentation</p>
<!-- Generated by Doxygen 1.8.6 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacellvm.html">llvm</a></li><li class="navelem"><a class="el" href="classllvm_1_1MemoryObject.html">MemoryObject</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classllvm_1_1MemoryObject-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">llvm::MemoryObject Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="MemoryObject_8h_source.html">MemoryObject.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for llvm::MemoryObject:</div>
<div class="dyncontent">
<div class="center"><img src="classllvm_1_1MemoryObject__inherit__graph.png" border="0" usemap="#llvm_1_1MemoryObject_inherit__map" alt="Inheritance graph"/></div>
<map name="llvm_1_1MemoryObject_inherit__map" id="llvm_1_1MemoryObject_inherit__map">
<area shape="rect" id="node2" href="classllvm_1_1StreamingMemoryObject.html" title="llvm::StreamingMemoryObject" alt="" coords="5,80,221,107"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a516bdb95d7df7788abfe4862c9cfcf2f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryObject.html#a516bdb95d7df7788abfe4862c9cfcf2f">~MemoryObject</a> ()</td></tr>
<tr class="separator:a516bdb95d7df7788abfe4862c9cfcf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332604f1ea8149479074a923ead6c5f3"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryObject.html#a332604f1ea8149479074a923ead6c5f3">getExtent</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> =0</td></tr>
<tr class="separator:a332604f1ea8149479074a923ead6c5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af290b7fbba09739ee78a0282715d9377"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryObject.html#af290b7fbba09739ee78a0282715d9377">readBytes</a> (uint8_t *Buf, uint64_t Size, uint64_t Address) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> =0</td></tr>
<tr class="separator:af290b7fbba09739ee78a0282715d9377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd03120f3675f2816968b22da8dbfc2a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryObject.html#afd03120f3675f2816968b22da8dbfc2a">getPointer</a> (uint64_t address, uint64_t size) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> =0</td></tr>
<tr class="separator:afd03120f3675f2816968b22da8dbfc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec334a0bf86405fa71001c10495d84ee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1MemoryObject.html#aec334a0bf86405fa71001c10495d84ee">isValidAddress</a> (uint64_t address) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> =0</td></tr>
<tr class="separator:aec334a0bf86405fa71001c10495d84ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface to data which might be streamed. Streamability has 2 important implications/restrictions. First, the data might not yet exist in memory when the request is made. This just means that readByte/readBytes might have to block or do some work to get it. More significantly, the exact size of the object might not be known until it has all been fetched. This means that to return the right result, getExtent must also wait for all the data to arrive; therefore it should not be called on objects which are actually streamed (this would defeat the purpose of streaming). Instead, isValidAddress can be used to test addresses without knowing the exact size of the stream. Finally, getPointer can be used instead of readBytes to avoid extra copying. </p>

<p>Definition at line <a class="el" href="MemoryObject_8h_source.html#l00028">28</a> of file <a class="el" href="MemoryObject_8h_source.html">MemoryObject.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a516bdb95d7df7788abfe4862c9cfcf2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MemoryObject::~MemoryObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="MemoryObject_8cpp_source.html#l00013">13</a> of file <a class="el" href="MemoryObject_8cpp_source.html">MemoryObject.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a332604f1ea8149479074a923ead6c5f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t llvm::MemoryObject::getExtent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the region in bytes. (The region is contiguous, so the highest valid address of the region is <a class="el" href="classllvm_1_1MemoryObject.html#a332604f1ea8149479074a923ead6c5f3">getExtent()</a> - 1).</p>
<dl class="section return"><dt>Returns</dt><dd>- The size of the region. </dd></dl>

<p>Implemented in <a class="el" href="classllvm_1_1StreamingMemoryObject.html#ae4bfed599c9cb7e80123f83a2b3765c3">llvm::StreamingMemoryObject</a>.</p>

<p>Referenced by <a class="el" href="BitstreamReader_8cpp_source.html#l00154">llvm::BitstreamCursor::readRecord()</a>, and <a class="el" href="BitstreamReader_8cpp_source.html#l00096">llvm::BitstreamCursor::skipRecord()</a>.</p>

</div>
</div>
<a class="anchor" id="afd03120f3675f2816968b22da8dbfc2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> uint8_t* llvm::MemoryObject::getPointer </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensures that the requested data is in memory, and returns a pointer to it. More efficient than using readBytes if the data is already in memory. May block until (address - base + size) bytes have been read </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- address of the byte, in the same space as getBase() </td></tr>
    <tr><td class="paramname">size</td><td>- amount of data that must be available on return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- valid pointer to the requested data </dd></dl>

<p>Implemented in <a class="el" href="classllvm_1_1StreamingMemoryObject.html#a78c9a4b45d88689bbfc9bde85cdff330">llvm::StreamingMemoryObject</a>.</p>

<p>Referenced by <a class="el" href="BitstreamReader_8cpp_source.html#l00154">llvm::BitstreamCursor::readRecord()</a>.</p>

</div>
</div>
<a class="anchor" id="aec334a0bf86405fa71001c10495d84ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> llvm::MemoryObject::isValidAddress </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the address is within the object (i.e. between base and base + extent - 1 inclusive). May block until (address - base) bytes have been read </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>- address of the byte, in the same space as getBase() </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- true if the address may be read with readByte() </dd></dl>

<p>Implemented in <a class="el" href="classllvm_1_1StreamingMemoryObject.html#a9dda9468d825c2676c70bb4388d9e8b6">llvm::StreamingMemoryObject</a>.</p>

<p>Referenced by <a class="el" href="BitstreamReader_8h_source.html#l00220">llvm::BitstreamCursor::canSkipToPos()</a>.</p>

</div>
</div>
<a class="anchor" id="af290b7fbba09739ee78a0282715d9377"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t llvm::MemoryObject::readBytes </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>Buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to read a contiguous range of bytes from the region, up to the end of the region.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Buf</td><td>- A pointer to a buffer to be filled in. Must be non-NULL and large enough to hold size bytes. </td></tr>
    <tr><td class="paramname">Size</td><td>- The number of bytes to copy. </td></tr>
    <tr><td class="paramname">Address</td><td>- The address of the first byte, in the same space as getBase(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- The number of bytes read. </dd></dl>

<p>Implemented in <a class="el" href="classllvm_1_1StreamingMemoryObject.html#a2e366133a9877a26e9b51301bc01fbee">llvm::StreamingMemoryObject</a>.</p>

<p>Referenced by <a class="el" href="BitstreamReader_8h_source.html#l00317">llvm::BitstreamCursor::fillCurWord()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="MemoryObject_8h_source.html">MemoryObject.h</a></li>
<li><a class="el" href="MemoryObject_8cpp_source.html">MemoryObject.cpp</a></li>
</ul>
</div><!-- contents -->
<hr>
<p class="footer">
Generated on Tue Dec 8 2015 01:09:00 for <a href="http://llvm.org/">LLVM</a> by
<a href="http://www.doxygen.org"><img src="doxygen.png" alt="Doxygen"
align="middle" border="0"/>1.8.6</a><br>
Copyright &copy; 2003-2014 University of Illinois at Urbana-Champaign.
All Rights Reserved.</p>
<hr>
<!--#include virtual="/attrib.incl" -->
</body>
</html>
