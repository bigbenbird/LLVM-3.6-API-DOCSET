<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="keywords" content="LLVM,Low Level Virtual Machine,C++,doxygen,API,documentation"/>
<meta name="description" content="C++ source code API documentation for LLVM."/>
<title>LLVM: InstCombineAndOrXor.cpp File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head><body>
<p class="title">LLVM API Documentation</p>
<!-- Generated by Doxygen 1.8.6 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4d9c1978b5f07b6adb33a8870a898946.html">llvm3.6</a></li><li class="navelem"><a class="el" href="dir_5fa7ecd8d95c317b32615506984470d8.html">lib</a></li><li class="navelem"><a class="el" href="dir_ed2be07ed72f5c44fcceed313c4db32e.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_9756732a50db3e2140ab264ec925c677.html">InstCombine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">InstCombineAndOrXor.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="InstCombine_8h_source.html">InstCombine.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="InstructionSimplify_8h_source.html">llvm/Analysis/InstructionSimplify.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ConstantRange_8h_source.html">llvm/IR/ConstantRange.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="Intrinsics_8h_source.html">llvm/IR/Intrinsics.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">llvm/IR/PatternMatch.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="CmpInstAnalysis_8h_source.html">llvm/Transforms/Utils/CmpInstAnalysis.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for InstCombineAndOrXor.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="InstCombineAndOrXor_8cpp__incl.png" border="0" usemap="#InstCombineAndOrXor_8cpp" alt=""/></div>
<map name="InstCombineAndOrXor_8cpp" id="InstCombineAndOrXor_8cpp">
<area shape="rect" id="node2" href="InstCombine_8h.html" title="InstCombine.h" alt="" coords="2060,87,2175,114"/><area shape="rect" id="node44" href="Intrinsics_8h.html" title="llvm/IR/Intrinsics.h" alt="" coords="3554,348,3689,375"/><area shape="rect" id="node46" href="PatternMatch_8h.html" title="llvm/IR/PatternMatch.h" alt="" coords="3185,177,3349,203"/><area shape="rect" id="node48" href="InstructionSimplify_8h.html" title="llvm/Analysis/Instruction\lSimplify.h" alt="" coords="3697,80,3871,121"/><area shape="rect" id="node49" href="ConstantRange_8h.html" title="llvm/IR/ConstantRange.h" alt="" coords="1422,423,1599,449"/><area shape="rect" id="node50" href="CmpInstAnalysis_8h.html" title="llvm/Transforms/Utils\l/CmpInstAnalysis.h" alt="" coords="2871,80,3025,121"/><area shape="rect" id="node3" href="InstCombineWorklist_8h.html" title="InstCombineWorklist.h" alt="" coords="228,348,391,375"/><area shape="rect" id="node17" href="AssumptionCache_8h.html" title="llvm/Analysis/Assumption\lCache.h" alt="" coords="2364,259,2548,300"/><area shape="rect" id="node26" href="Pass_8h.html" title="llvm/Pass.h" alt="" coords="1924,497,2017,524"/><area shape="rect" id="node27" href="TargetFolder_8h.html" title="llvm/Analysis/TargetFolder.h" alt="" coords="3104,348,3301,375"/><area shape="rect" id="node31" href="ValueTracking_8h.html" title="llvm/Analysis/ValueTracking.h" alt="" coords="2539,497,2746,524"/><area shape="rect" id="node32" href="Dominators_8h.html" title="llvm/IR/Dominators.h" alt="" coords="1079,177,1233,203"/><area shape="rect" id="node37" href="IRBuilder_8h.html" title="llvm/IR/IRBuilder.h" alt="" coords="1848,266,1981,293"/><area shape="rect" id="node40" href="Operator_8h.html" title="llvm/IR/Operator.h" alt="" coords="2050,348,2185,375"/><area shape="rect" id="node41" href="InstVisitor_8h.html" title="llvm/IR/InstVisitor.h" alt="" coords="3019,177,3160,203"/><area shape="rect" id="node43" href="IntrinsicInst_8h.html" title="llvm/IR/IntrinsicInst.h" alt="" coords="2969,266,3119,293"/><area shape="rect" id="node47" href="SimplifyLibCalls_8h.html" title="llvm/Transforms/Utils\l/SimplifyLibCalls.h" alt="" coords="1776,169,1931,211"/><area shape="rect" id="node4" href="DenseMap_8h.html" title="llvm/ADT/DenseMap.h" alt="" coords="245,497,408,524"/><area shape="rect" id="node5" href="Compiler_8h.html" title="llvm/Support/Compiler.h" alt="" coords="993,721,1167,748"/><area shape="rect" id="node7" href="SmallVector_8h.html" title="llvm/ADT/SmallVector.h" alt="" coords="2117,647,2288,673"/><area shape="rect" id="node9" href="Instruction_8h.html" title="llvm/IR/Instruction.h" alt="" coords="2771,497,2917,524"/><area shape="rect" id="node12" href="Debug_8h.html" title="llvm/Support/Debug.h" alt="" coords="347,423,509,449"/><area shape="rect" id="node13" href="raw__ostream_8h.html" title="llvm/Support/raw_ostream.h" alt="" coords="479,497,681,524"/><area shape="rect" id="node10" href="ArrayRef_8h.html" title="llvm/ADT/ArrayRef.h" alt="" coords="2827,572,2973,599"/><area shape="rect" id="node11" href="User_8h.html" title="llvm/IR/User.h" alt="" coords="3155,572,3263,599"/><area shape="rect" id="node14" href="StringRef_8h.html" title="llvm/ADT/StringRef.h" alt="" coords="1218,572,1369,599"/><area shape="rect" id="node18" href="SmallSet_8h.html" title="llvm/ADT/SmallSet.h" alt="" coords="2227,423,2379,449"/><area shape="rect" id="node20" href="Function_8h.html" title="llvm/IR/Function.h" alt="" coords="2795,348,2927,375"/><area shape="rect" id="node23" href="Instructions_8h.html" title="llvm/IR/Instructions.h" alt="" coords="3377,348,3530,375"/><area shape="rect" id="node25" href="ValueHandle_8h.html" title="llvm/IR/ValueHandle.h" alt="" coords="2209,348,2367,375"/><area shape="rect" id="node19" href="SmallPtrSet_8h.html" title="llvm/ADT/SmallPtrSet.h" alt="" coords="1075,497,1245,524"/><area shape="rect" id="node21" href="BasicBlock_8h.html" title="llvm/IR/BasicBlock.h" alt="" coords="1776,423,1923,449"/><area shape="rect" id="node22" href="Twine_8h.html" title="llvm/ADT/Twine.h" alt="" coords="1371,497,1498,524"/><area shape="rect" id="node24" href="InstrTypes_8h.html" title="llvm/IR/InstrTypes.h" alt="" coords="2825,423,2967,449"/><area shape="rect" id="node28" href="ConstantFolding_8h.html" title="llvm/Analysis/ConstantFolding.h" alt="" coords="3143,423,3366,449"/><area shape="rect" id="node29" href="Constants_8h.html" title="llvm/IR/Constants.h" alt="" coords="2656,423,2800,449"/><area shape="rect" id="node30" href="APInt_8h.html" title="This file implements a class to represent arbitrary precision integral constant values and operations..." alt="" coords="1675,497,1802,524"/><area shape="rect" id="node33" href="DepthFirstIterator_8h.html" title="llvm/ADT/DepthFirstIterator.h" alt="" coords="888,423,1093,449"/><area shape="rect" id="node34" href="GraphTraits_8h.html" title="llvm/ADT/GraphTraits.h" alt="" coords="786,497,953,524"/><area shape="rect" id="node35" href="IR_2CFG_8h.html" title="llvm/IR/CFG.h" alt="" coords="2221,266,2326,293"/><area shape="rect" id="node36" href="GenericDomTree_8h.html" title="llvm/Support/GenericDomTree.h" alt="" coords="634,348,859,375"/><area shape="rect" id="node38" href="ConstantFolder_8h.html" title="llvm/IR/ConstantFolder.h" alt="" coords="2494,348,2669,375"/><area shape="rect" id="node39" href="DataLayout_8h.html" title="llvm/IR/DataLayout.h" alt="" coords="1947,423,2101,449"/><area shape="rect" id="node42" href="CallSite_8h.html" title="llvm/IR/CallSite.h" alt="" coords="3297,266,3423,293"/></map>
</div>
</div>
<p><a href="InstCombineAndOrXor_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;instcombine&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa9c705ecec80ebd584bb3d54b48f7ee1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1">MaskedICmpType</a> { <br/>
&#160;&#160;<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a8ab26b389e7b7199477e4e6f4a449c07">FoldMskICmp_AMask_AllOnes</a> = 1, 
<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1af9642ecdbd6386078c05024c75a8b585">FoldMskICmp_AMask_NotAllOnes</a> = 2, 
<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a1932a1cae8878c1e59fff843ded5af4a">FoldMskICmp_BMask_AllOnes</a> = 4, 
<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a22226cf1a76711e1bb4ffceaa452f654">FoldMskICmp_BMask_NotAllOnes</a> = 8, 
<br/>
&#160;&#160;<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1ac406b89f196729d12023595c30b244d4">FoldMskICmp_Mask_AllZeroes</a> = 16, 
<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1afb2ea884e4e94dd5f644bf5fc410580a">FoldMskICmp_Mask_NotAllZeroes</a> = 32, 
<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a6bab48061337e60eb9c79650fd8e08e2">FoldMskICmp_AMask_Mixed</a> = 64, 
<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1aa8d5b5f3227910eddb03cce79f461af2">FoldMskICmp_AMask_NotMixed</a> = 128, 
<br/>
&#160;&#160;<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a2778ef2a236b30d557c19e8d4cf27f66">FoldMskICmp_BMask_Mixed</a> = 256, 
<a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1a87e4869a2403fea5c04b47663119bf62">FoldMskICmp_BMask_NotMixed</a> = 512
<br/>
 }</td></tr>
<tr class="separator:aa9c705ecec80ebd584bb3d54b48f7ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afa152a1c292e3c6e4c11ac7ac34c38c3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#afa152a1c292e3c6e4c11ac7ac34c38c3">isFreeToInvert</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V)</td></tr>
<tr class="separator:afa152a1c292e3c6e4c11ac7ac34c38c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62fbad44784b52824ea165a4695299f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#aa62fbad44784b52824ea165a4695299f">dyn_castNotVal</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V)</td></tr>
<tr class="separator:aa62fbad44784b52824ea165a4695299f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32ead1eb9f9f19667b0f79d01214612b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a32ead1eb9f9f19667b0f79d01214612b">getFCmpCode</a> (FCmpInst::Predicate CC, <a class="el" href="classbool.html">bool</a> &amp;isOrdered)</td></tr>
<tr class="separator:a32ead1eb9f9f19667b0f79d01214612b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529ff4b10087991fd0e737adbf94b423"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a529ff4b10087991fd0e737adbf94b423">getNewICmpValue</a> (<a class="el" href="classbool.html">bool</a> Sign, <a class="el" href="classunsigned.html">unsigned</a> Code, <a class="el" href="classllvm_1_1Value.html">Value</a> *LHS, <a class="el" href="classllvm_1_1Value.html">Value</a> *RHS, <a class="el" href="classllvm_1_1InstCombiner.html#aa733c1cd80a60826574461f05ede6e84">InstCombiner::BuilderTy</a> *Builder)</td></tr>
<tr class="separator:a529ff4b10087991fd0e737adbf94b423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7627ec3ea1e8ae5e84826e213b917abc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a7627ec3ea1e8ae5e84826e213b917abc">getFCmpValue</a> (<a class="el" href="classbool.html">bool</a> isordered, <a class="el" href="classunsigned.html">unsigned</a> code, <a class="el" href="classllvm_1_1Value.html">Value</a> *LHS, <a class="el" href="classllvm_1_1Value.html">Value</a> *RHS, <a class="el" href="classllvm_1_1InstCombiner.html#aa733c1cd80a60826574461f05ede6e84">InstCombiner::BuilderTy</a> *Builder)</td></tr>
<tr class="separator:a7627ec3ea1e8ae5e84826e213b917abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add947a35dd442e049fda602d9dc9cd20"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#add947a35dd442e049fda602d9dc9cd20">isRunOfOnes</a> (<a class="el" href="classllvm_1_1ConstantInt.html">ConstantInt</a> *Val, uint32_t &amp;MB, uint32_t &amp;ME)</td></tr>
<tr class="separator:add947a35dd442e049fda602d9dc9cd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed27d8ce11c8fb8b5cac79cc959bd5db"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#aed27d8ce11c8fb8b5cac79cc959bd5db">getTypeOfMaskedICmp</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *A, <a class="el" href="classllvm_1_1Value.html">Value</a> *B, <a class="el" href="classllvm_1_1Value.html">Value</a> *C, ICmpInst::Predicate SCC)</td></tr>
<tr class="separator:aed27d8ce11c8fb8b5cac79cc959bd5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c36c07a47775cef8f8e93d8090d919"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a09c36c07a47775cef8f8e93d8090d919">conjugateICmpMask</a> (<a class="el" href="classunsigned.html">unsigned</a> Mask)</td></tr>
<tr class="separator:a09c36c07a47775cef8f8e93d8090d919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75e7b9606d30b9bde1384efd6917580"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#aa75e7b9606d30b9bde1384efd6917580">decomposeBitTestICmp</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, ICmpInst::Predicate &amp;Pred, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="Hello_8cpp.html#a8c52190361e97ffdef605d3479a11551">X</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;<a class="el" href="Hello_8cpp.html#af7a9e9117a5e3a101250445ff373b42a">Y</a>, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;Z)</td></tr>
<tr class="separator:aa75e7b9606d30b9bde1384efd6917580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187cc5f9a7a949ba824b4ebc18858f1a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a187cc5f9a7a949ba824b4ebc18858f1a">foldLogOpOfMaskedICmpsHelper</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;A, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;B, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;C, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;D, <a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;E, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *LHS, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *RHS, ICmpInst::Predicate &amp;LHSCC, ICmpInst::Predicate &amp;RHSCC)</td></tr>
<tr class="separator:a187cc5f9a7a949ba824b4ebc18858f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907d394944052b35b29b6f6e0c923e08"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a907d394944052b35b29b6f6e0c923e08">foldLogOpOfMaskedICmps</a> (<a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *LHS, <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *RHS, <a class="el" href="classbool.html">bool</a> IsAnd, <a class="el" href="classllvm_1_1InstCombiner.html#aa733c1cd80a60826574461f05ede6e84">llvm::InstCombiner::BuilderTy</a> *Builder)</td></tr>
<tr class="separator:a907d394944052b35b29b6f6e0c923e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6495ab03039b1ee2bfecf5e1d5ae3c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#aea6495ab03039b1ee2bfecf5e1d5ae3c">CollectBSwapParts</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, int OverallLeftShift, uint32_t ByteMask, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;ByteValues)</td></tr>
<tr class="separator:aea6495ab03039b1ee2bfecf5e1d5ae3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f11c9f64a41930051d33f8dfcfab10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineAndOrXor_8cpp.html#a20f11c9f64a41930051d33f8dfcfab10">MatchSelectFromAndOr</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *A, <a class="el" href="classllvm_1_1Value.html">Value</a> *B, <a class="el" href="classllvm_1_1Value.html">Value</a> *C, <a class="el" href="classllvm_1_1Value.html">Value</a> *D)</td></tr>
<tr class="separator:a20f11c9f64a41930051d33f8dfcfab10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;instcombine&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00023">23</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aa9c705ecec80ebd584bb3d54b48f7ee1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="InstCombineAndOrXor_8cpp.html#aa9c705ecec80ebd584bb3d54b48f7ee1">MaskedICmpType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>enum for classifying (icmp eq (A &amp; B), C) and (icmp ne (A &amp; B), C) One of A and B is considered the mask, the other the value. This is described as the "AMask" or "BMask" part of the enum. If the enum contains only "Mask", then both A and B can be considered masks. If A is the mask, then it was proven, that (A &amp; C) == C. This is trivial if C == A, or C == 0. If both A and C are constants, this proof is also easy. For the following explanations we assume that A is the mask. The part "AllOnes" declares, that the comparison is true only if (A &amp; B) == A, or all bits of A are set in B. Example: (icmp eq (A &amp; 3), 3) -&gt; FoldMskICmp_AMask_AllOnes The part "AllZeroes" declares, that the comparison is true only if (A &amp; B) == 0, or all bits of A are cleared in B. Example: (icmp eq (A &amp; 3), 0) -&gt; FoldMskICmp_Mask_AllZeroes The part "Mixed" declares, that (A &amp; B) == C and C might or might not contain any number of one bits and zero bits. Example: (icmp eq (A &amp; 3), 1) -&gt; FoldMskICmp_AMask_Mixed The Part "Not" means, that in above descriptions "==" should be replaced by "!=". Example: (icmp ne (A &amp; 3), 3) -&gt; FoldMskICmp_AMask_NotAllOnes If the mask A contains a single bit, then the following is equivalent: (icmp eq (A &amp; B), A) equals (icmp ne (A &amp; B), 0) (icmp ne (A &amp; B), A) equals (icmp eq (A &amp; B), 0) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aa9c705ecec80ebd584bb3d54b48f7ee1a8ab26b389e7b7199477e4e6f4a449c07"></a>FoldMskICmp_AMask_AllOnes</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9c705ecec80ebd584bb3d54b48f7ee1af9642ecdbd6386078c05024c75a8b585"></a>FoldMskICmp_AMask_NotAllOnes</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9c705ecec80ebd584bb3d54b48f7ee1a1932a1cae8878c1e59fff843ded5af4a"></a>FoldMskICmp_BMask_AllOnes</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9c705ecec80ebd584bb3d54b48f7ee1a22226cf1a76711e1bb4ffceaa452f654"></a>FoldMskICmp_BMask_NotAllOnes</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9c705ecec80ebd584bb3d54b48f7ee1ac406b89f196729d12023595c30b244d4"></a>FoldMskICmp_Mask_AllZeroes</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9c705ecec80ebd584bb3d54b48f7ee1afb2ea884e4e94dd5f644bf5fc410580a"></a>FoldMskICmp_Mask_NotAllZeroes</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9c705ecec80ebd584bb3d54b48f7ee1a6bab48061337e60eb9c79650fd8e08e2"></a>FoldMskICmp_AMask_Mixed</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9c705ecec80ebd584bb3d54b48f7ee1aa8d5b5f3227910eddb03cce79f461af2"></a>FoldMskICmp_AMask_NotMixed</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9c705ecec80ebd584bb3d54b48f7ee1a2778ef2a236b30d557c19e8d4cf27f66"></a>FoldMskICmp_BMask_Mixed</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aa9c705ecec80ebd584bb3d54b48f7ee1a87e4869a2403fea5c04b47663119bf62"></a>FoldMskICmp_BMask_NotMixed</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00456">456</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aea6495ab03039b1ee2bfecf5e1d5ae3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> CollectBSwapParts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>OverallLeftShift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ByteMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ByteValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>CollectBSwapParts - Analyze the specified subexpression and see if it is capable of providing pieces of a bswap. The subexpression provides pieces of a bswap if it is proven that each of the non-zero bytes in the output of the expression came from the corresponding "byte swapped" byte in some other value. For example, if the current subexpression is "(shl i32 %X, 24)" then we know that the expression deposits the low byte of X into the high byte of the bswap result and that all other bytes are zero. This expression is accepted, the high byte of ByteValues is set to X to indicate a correct match.</p>
<p>This function returns true if the match was unsuccessful and false if so. On entry to the function the "OverallLeftShift" is a signed integer value indicating the number of bytes that the subexpression is later shifted. For example, if the expression is later right shifted by 16 bits, the OverallLeftShift value would be -2 on entry. This is used to specify which byte of ByteValues is actually being set.</p>
<p>Similarly, ByteMask is a bitmask where a bit is clear if its corresponding byte is masked to zero by a user. For example, in (X &amp; 255), X will be processed with a bytemask of 1. Because bytemask is 32-bits, this limits this function to working on up to 32-byte (256 bit) values. ByteMask is always in the local (OverallLeftShift) coordinate space. </p>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01552">1552</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="APInt_8h_source.html#l01878">llvm::APIntOps::And()</a>, <a class="el" href="MathExtras_8h_source.html#l00048">llvm::countTrailingZeros()</a>, <a class="el" href="Instruction_8h_source.html#l00087">llvm::Instruction::getOpcode()</a>, <a class="el" href="User_8h_source.html#l00089">llvm::User::getOperand()</a>, <a class="el" href="Type_8cpp_source.html#l00121">llvm::Type::getPrimitiveSizeInBits()</a>, <a class="el" href="Value_8h_source.html#l00222">llvm::Value::getType()</a>, <a class="el" href="Instruction_8h_source.html#l00112">llvm::Instruction::isLogicalShift()</a>, <a class="el" href="MathExtras_8h_source.html#l00362">llvm::isPowerOf2_32()</a>, <a class="el" href="APInt_8h_source.html#l01883">llvm::APIntOps::Or()</a>, and <a class="el" href="SmallVector_8h_source.html#l00126">llvm::SmallVectorTemplateCommon&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a09c36c07a47775cef8f8e93d8090d919"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> conjugateICmpMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert an analysis of a masked ICmp into its equivalent if all boolean operations had the opposite sense. Since each "NotXXX" flag (recording !=) is adjacent to the corresponding normal flag (recording ==), this just involves swapping those bits over. </p>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00542">542</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00457">FoldMskICmp_AMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00463">FoldMskICmp_AMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00458">FoldMskICmp_AMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00464">FoldMskICmp_AMask_NotMixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00459">FoldMskICmp_BMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00465">FoldMskICmp_BMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00460">FoldMskICmp_BMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00466">FoldMskICmp_BMask_NotMixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00461">FoldMskICmp_Mask_AllZeroes</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00462">FoldMskICmp_Mask_NotAllZeroes</a>.</p>

<p>Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00723">foldLogOpOfMaskedICmps()</a>.</p>

</div>
</div>
<a class="anchor" id="aa75e7b9606d30b9bde1384efd6917580"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> decomposeBitTestICmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate &amp;&#160;</td>
          <td class="paramname"><em>Pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>Z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>decomposeBitTestICmp - Decompose an icmp into the form ((X &amp; Y) pred Z) if possible. The returned predicate is either == or !=. Returns false if decomposition fails. </p>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00561">561</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="Casting_8h_source.html#l00285">llvm::dyn_cast()</a>, <a class="el" href="Constants_8cpp_source.html#l00571">llvm::ConstantInt::get()</a>, <a class="el" href="Constants_8h_source.html#l00106">llvm::ConstantInt::getBitWidth()</a>, <a class="el" href="Value_8cpp_source.html#l00614">llvm::Value::getContext()</a>, <a class="el" href="Constants_8cpp_source.html#l00178">llvm::Constant::getNullValue()</a>, <a class="el" href="User_8h_source.html#l00089">llvm::User::getOperand()</a>, <a class="el" href="InstrTypes_8h_source.html#l00757">llvm::CmpInst::getPredicate()</a>, <a class="el" href="APInt_8h_source.html#l00442">llvm::APInt::getSignBit()</a>, <a class="el" href="Constants_8h_source.html#l00135">llvm::ConstantInt::getType()</a>, <a class="el" href="Constants_8h_source.html#l00101">llvm::ConstantInt::getValue()</a>, <a class="el" href="InstrTypes_8h_source.html#l00715">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00716">llvm::CmpInst::ICMP_NE</a>, <a class="el" href="InstrTypes_8h_source.html#l00721">llvm::CmpInst::ICMP_SGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00723">llvm::CmpInst::ICMP_SLT</a>, <a class="el" href="InstrTypes_8h_source.html#l00717">llvm::CmpInst::ICMP_UGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00719">llvm::CmpInst::ICMP_ULT</a>, <a class="el" href="Constants_8cpp_source.html#l00088">llvm::Constant::isAllOnesValue()</a>, <a class="el" href="APInt_8h_source.html#l00389">llvm::APInt::isPowerOf2()</a>, and <a class="el" href="Constants_8h_source.html#l00156">llvm::ConstantInt::isZero()</a>.</p>

<p>Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00609">foldLogOpOfMaskedICmpsHelper()</a>.</p>

</div>
</div>
<a class="anchor" id="aa62fbad44784b52824ea165a4695299f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* dyn_castNotVal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00043">43</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="Constants_8cpp_source.html#l00571">llvm::ConstantInt::get()</a>, <a class="el" href="Instructions_8cpp_source.html#l01990">llvm::BinaryOperator::getNotArgument()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00027">isFreeToInvert()</a>, and <a class="el" href="Instructions_8cpp_source.html#l01955">llvm::BinaryOperator::isNot()</a>.</p>

<p>Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01223">llvm::InstCombiner::visitAnd()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02159">llvm::InstCombiner::visitOr()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02546">llvm::InstCombiner::visitXor()</a>.</p>

</div>
</div>
<a class="anchor" id="a907d394944052b35b29b6f6e0c923e08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* foldLogOpOfMaskedICmps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>IsAnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#aa733c1cd80a60826574461f05ede6e84">llvm::InstCombiner::BuilderTy</a> *&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>foldLogOpOfMaskedICmps: try to fold (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E) into a single (icmp(A &amp; X) ==/!= Y) </p>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00723">723</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="ARMBaseInfo_8h_source.html#l00098">llvm::ARM_PROC::A</a>, <a class="el" href="GlobalMerge_8cpp.html#a65c1240c404c646dd0e63fdcbf620730">assert()</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00542">conjugateICmpMask()</a>, <a class="el" href="IRBuilder_8h_source.html#l00861">llvm::IRBuilder&lt; preserveNames, T, Inserter &gt;::CreateAnd()</a>, <a class="el" href="IRBuilder_8h_source.html#l01388">llvm::IRBuilder&lt; preserveNames, T, Inserter &gt;::CreateICmp()</a>, <a class="el" href="IRBuilder_8h_source.html#l00877">llvm::IRBuilder&lt; preserveNames, T, Inserter &gt;::CreateOr()</a>, <a class="el" href="Casting_8h_source.html#l00285">llvm::dyn_cast()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00609">foldLogOpOfMaskedICmpsHelper()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00457">FoldMskICmp_AMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00458">FoldMskICmp_AMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00459">FoldMskICmp_BMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00465">FoldMskICmp_BMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00460">FoldMskICmp_BMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00461">FoldMskICmp_Mask_AllZeroes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00462">FoldMskICmp_Mask_NotAllZeroes</a>, <a class="el" href="Constants_8cpp_source.html#l00571">llvm::ConstantInt::get()</a>, <a class="el" href="Constants_8cpp_source.html#l00178">llvm::Constant::getNullValue()</a>, <a class="el" href="Constants_8cpp_source.html#l02288">llvm::ConstantExpr::getOr()</a>, <a class="el" href="InstrTypes_8h_source.html#l00757">llvm::CmpInst::getPredicate()</a>, <a class="el" href="Value_8h_source.html#l00222">llvm::Value::getType()</a>, <a class="el" href="Constants_8h_source.html#l00101">llvm::ConstantInt::getValue()</a>, <a class="el" href="Constants_8cpp_source.html#l02292">llvm::ConstantExpr::getXor()</a>, <a class="el" href="InstrTypes_8h_source.html#l00715">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00716">llvm::CmpInst::ICMP_NE</a>, and <a class="el" href="Instructions_8h_source.html#l01083">llvm::ICmpInst::isEquality()</a>.</p>

<p>Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00900">llvm::InstCombiner::FoldAndOfICmps()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01709">llvm::InstCombiner::FoldOrOfICmps()</a>.</p>

</div>
</div>
<a class="anchor" id="a187cc5f9a7a949ba824b4ebc18858f1a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> foldLogOpOfMaskedICmpsHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ICmpInst.html">ICmpInst</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate &amp;&#160;</td>
          <td class="paramname"><em>LHSCC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate &amp;&#160;</td>
          <td class="paramname"><em>RHSCC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>foldLogOpOfMaskedICmpsHelper: handle (icmp(A &amp; B) ==/!= C) &amp;/| (icmp(A &amp; D) ==/!= E) return the set of pattern classes (from MaskedICmpType) that both LHS and RHS satisfy </p>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00609">609</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00561">decomposeBitTestICmp()</a>, <a class="el" href="Constants_8cpp_source.html#l00230">llvm::Constant::getAllOnesValue()</a>, <a class="el" href="User_8h_source.html#l00089">llvm::User::getOperand()</a>, <a class="el" href="Value_8h_source.html#l00222">llvm::Value::getType()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00471">getTypeOfMaskedICmp()</a>, <a class="el" href="Instructions_8h_source.html#l01083">llvm::ICmpInst::isEquality()</a>, <a class="el" href="Type_8h_source.html#l00193">llvm::Type::isIntegerTy()</a>, <a class="el" href="Type_8h_source.html#l00226">llvm::Type::isVectorTy()</a>, <a class="el" href="PatternMatch_8h_source.html#l00503">llvm::PatternMatch::m_And()</a>, <a class="el" href="PatternMatch_8h_source.html#l00064">llvm::PatternMatch::m_Value()</a>, <a class="el" href="PatternMatch_8h_source.html#l00041">llvm::PatternMatch::match()</a>, and <a class="el" href="MathExtras_8h.html#a9211f62d8e1e6de999eaa63ec0f6ae02">R2</a>.</p>

<p>Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00723">foldLogOpOfMaskedICmps()</a>.</p>

</div>
</div>
<a class="anchor" id="a32ead1eb9f9f19667b0f79d01214612b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> getFCmpCode </td>
          <td>(</td>
          <td class="paramtype">FCmpInst::Predicate&#160;</td>
          <td class="paramname"><em>CC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>isOrdered</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>getFCmpCode - Similar to getICmpCode but for FCmpInst. This encodes a fcmp predicate into a three bit mask. It also returns whether it is an ordered predicate by reference. </p>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00061">61</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="InstrTypes_8h_source.html#l00697">llvm::CmpInst::FCMP_OEQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00699">llvm::CmpInst::FCMP_OGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00698">llvm::CmpInst::FCMP_OGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00701">llvm::CmpInst::FCMP_OLE</a>, <a class="el" href="InstrTypes_8h_source.html#l00700">llvm::CmpInst::FCMP_OLT</a>, <a class="el" href="InstrTypes_8h_source.html#l00702">llvm::CmpInst::FCMP_ONE</a>, <a class="el" href="InstrTypes_8h_source.html#l00703">llvm::CmpInst::FCMP_ORD</a>, <a class="el" href="InstrTypes_8h_source.html#l00705">llvm::CmpInst::FCMP_UEQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00707">llvm::CmpInst::FCMP_UGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00706">llvm::CmpInst::FCMP_UGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00709">llvm::CmpInst::FCMP_ULE</a>, <a class="el" href="InstrTypes_8h_source.html#l00708">llvm::CmpInst::FCMP_ULT</a>, <a class="el" href="InstrTypes_8h_source.html#l00710">llvm::CmpInst::FCMP_UNE</a>, <a class="el" href="InstrTypes_8h_source.html#l00704">llvm::CmpInst::FCMP_UNO</a>, and <a class="el" href="ErrorHandling_8h_source.html#l00098">llvm_unreachable</a>.</p>

<p>Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01146">llvm::InstCombiner::FoldAndOfFCmps()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02041">llvm::InstCombiner::FoldOrOfFCmps()</a>.</p>

</div>
</div>
<a class="anchor" id="a7627ec3ea1e8ae5e84826e213b917abc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* getFCmpValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isordered</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#aa733c1cd80a60826574461f05ede6e84">InstCombiner::BuilderTy</a> *&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>getFCmpValue - This is the complement of getFCmpCode, which turns an opcode and two operands into either a FCmp instruction. isordered is passed in to determine which kind of predicate to use in the new fcmp instruction. </p>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00100">100</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="IRBuilder_8h_source.html#l01395">llvm::IRBuilder&lt; preserveNames, T, Inserter &gt;::CreateFCmp()</a>, <a class="el" href="InstrTypes_8h_source.html#l00697">llvm::CmpInst::FCMP_OEQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00699">llvm::CmpInst::FCMP_OGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00698">llvm::CmpInst::FCMP_OGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00701">llvm::CmpInst::FCMP_OLE</a>, <a class="el" href="InstrTypes_8h_source.html#l00700">llvm::CmpInst::FCMP_OLT</a>, <a class="el" href="InstrTypes_8h_source.html#l00702">llvm::CmpInst::FCMP_ONE</a>, <a class="el" href="InstrTypes_8h_source.html#l00703">llvm::CmpInst::FCMP_ORD</a>, <a class="el" href="InstrTypes_8h_source.html#l00705">llvm::CmpInst::FCMP_UEQ</a>, <a class="el" href="InstrTypes_8h_source.html#l00707">llvm::CmpInst::FCMP_UGE</a>, <a class="el" href="InstrTypes_8h_source.html#l00706">llvm::CmpInst::FCMP_UGT</a>, <a class="el" href="InstrTypes_8h_source.html#l00709">llvm::CmpInst::FCMP_ULE</a>, <a class="el" href="InstrTypes_8h_source.html#l00708">llvm::CmpInst::FCMP_ULT</a>, <a class="el" href="InstrTypes_8h_source.html#l00710">llvm::CmpInst::FCMP_UNE</a>, <a class="el" href="InstrTypes_8h_source.html#l00704">llvm::CmpInst::FCMP_UNO</a>, <a class="el" href="Value_8cpp_source.html#l00614">llvm::Value::getContext()</a>, <a class="el" href="Constants_8cpp_source.html#l00519">llvm::ConstantInt::getTrue()</a>, and <a class="el" href="ErrorHandling_8h_source.html#l00098">llvm_unreachable</a>.</p>

<p>Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01146">llvm::InstCombiner::FoldAndOfFCmps()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02041">llvm::InstCombiner::FoldOrOfFCmps()</a>.</p>

</div>
</div>
<a class="anchor" id="a529ff4b10087991fd0e737adbf94b423"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* getNewICmpValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>Sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>Code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>LHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>RHS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html#aa733c1cd80a60826574461f05ede6e84">InstCombiner::BuilderTy</a> *&#160;</td>
          <td class="paramname"><em>Builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>getNewICmpValue - This is the complement of getICmpCode, which turns an opcode and two operands into either a constant true or false, or a brand new ICmp instruction. The sign is passed in to determine which kind of predicate to use in the new icmp instruction. </p>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00089">89</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="IRBuilder_8h_source.html#l01388">llvm::IRBuilder&lt; preserveNames, T, Inserter &gt;::CreateICmp()</a>, and <a class="el" href="CmpInstAnalysis_8cpp_source.html#l00072">llvm::getICmpValue()</a>.</p>

<p>Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00900">llvm::InstCombiner::FoldAndOfICmps()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01709">llvm::InstCombiner::FoldOrOfICmps()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02546">llvm::InstCombiner::visitXor()</a>.</p>

</div>
</div>
<a class="anchor" id="aed27d8ce11c8fb8b5cac79cc959bd5db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classunsigned.html">unsigned</a> getTypeOfMaskedICmp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ICmpInst::Predicate&#160;</td>
          <td class="paramname"><em>SCC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>return the set of pattern classes (from MaskedICmpType) that (icmp SCC (A &amp; B), C) satisfies </p>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00471">471</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="ARMBaseInfo_8h_source.html#l00098">llvm::ARM_PROC::A</a>, <a class="el" href="CallingConv_8h_source.html#l00034">llvm::CallingConv::C</a>, <a class="el" href="Casting_8h_source.html#l00285">llvm::dyn_cast()</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00457">FoldMskICmp_AMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00463">FoldMskICmp_AMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00458">FoldMskICmp_AMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00464">FoldMskICmp_AMask_NotMixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00459">FoldMskICmp_BMask_AllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00465">FoldMskICmp_BMask_Mixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00460">FoldMskICmp_BMask_NotAllOnes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00466">FoldMskICmp_BMask_NotMixed</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00461">FoldMskICmp_Mask_AllZeroes</a>, <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00462">FoldMskICmp_Mask_NotAllZeroes</a>, <a class="el" href="Constants_8cpp_source.html#l02284">llvm::ConstantExpr::getAnd()</a>, <a class="el" href="Constants_8h_source.html#l00101">llvm::ConstantInt::getValue()</a>, <a class="el" href="InstrTypes_8h_source.html#l00715">llvm::CmpInst::ICMP_EQ</a>, <a class="el" href="APInt_8h_source.html#l00389">llvm::APInt::isPowerOf2()</a>, and <a class="el" href="Constants_8h_source.html#l00156">llvm::ConstantInt::isZero()</a>.</p>

<p>Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00609">foldLogOpOfMaskedICmpsHelper()</a>.</p>

</div>
</div>
<a class="anchor" id="afa152a1c292e3c6e4c11ac7ac34c38c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isFreeToInvert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>isFreeToInvert - Return true if the specified value is free to invert (apply ~ to). This happens in cases where the ~ can be eliminated. </p>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00027">27</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="Instructions_8cpp_source.html#l01955">llvm::BinaryOperator::isNot()</a>.</p>

<p>Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00043">dyn_castNotVal()</a>, and <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02546">llvm::InstCombiner::visitXor()</a>.</p>

</div>
</div>
<a class="anchor" id="add947a35dd442e049fda602d9dc9cd20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isRunOfOnes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ConstantInt.html">ConstantInt</a> *&#160;</td>
          <td class="paramname"><em>Val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>MB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>ME</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l00365">365</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="APInt_8h_source.html#l01285">llvm::APInt::getActiveBits()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00061">llvm::IntegerType::getBitWidth()</a>, <a class="el" href="Constants_8h_source.html#l00135">llvm::ConstantInt::getType()</a>, <a class="el" href="Constants_8h_source.html#l00101">llvm::ConstantInt::getValue()</a>, and <a class="el" href="APInt_8h_source.html#l01762">llvm::APIntOps::isShiftedMask()</a>.</p>

</div>
</div>
<a class="anchor" id="a20f11c9f64a41930051d33f8dfcfab10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a>* MatchSelectFromAndOr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>MatchSelectFromAndOr - We have an expression of the form (A&amp;C)|(B&amp;D). Check If A is (cond?-1:0) and either B or D is ~(cond?-1,0) or (cond?0,-1), then we can simplify this expression to "cond ? C : D or B". </p>

<p>Definition at line <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l01686">1686</a> of file <a class="el" href="InstCombineAndOrXor_8cpp_source.html">InstCombineAndOrXor.cpp</a>.</p>

<p>References <a class="el" href="Instructions_8h_source.html#l01567">llvm::SelectInst::Create()</a>, <a class="el" href="Value_8h_source.html#l00222">llvm::Value::getType()</a>, <a class="el" href="Type_8h_source.html#l00193">llvm::Type::isIntegerTy()</a>, <a class="el" href="PatternMatch_8h_source.html#l00851">llvm::PatternMatch::m_Not()</a>, <a class="el" href="PatternMatch_8h_source.html#l00804">llvm::PatternMatch::m_SExt()</a>, <a class="el" href="PatternMatch_8h_source.html#l00319">llvm::PatternMatch::m_Specific()</a>, <a class="el" href="PatternMatch_8h_source.html#l00064">llvm::PatternMatch::m_Value()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00041">llvm::PatternMatch::match()</a>.</p>

<p>Referenced by <a class="el" href="InstCombineAndOrXor_8cpp_source.html#l02159">llvm::InstCombiner::visitOr()</a>.</p>

</div>
</div>
</div><!-- contents -->
<hr>
<p class="footer">
Generated on Tue Dec 8 2015 00:59:49 for <a href="http://llvm.org/">LLVM</a> by
<a href="http://www.doxygen.org"><img src="doxygen.png" alt="Doxygen"
align="middle" border="0"/>1.8.6</a><br>
Copyright &copy; 2003-2014 University of Illinois at Urbana-Champaign.
All Rights Reserved.</p>
<hr>
<!--#include virtual="/attrib.incl" -->
</body>
</html>
