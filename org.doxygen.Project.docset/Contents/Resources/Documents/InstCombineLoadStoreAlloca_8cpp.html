<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="keywords" content="LLVM,Low Level Virtual Machine,C++,doxygen,API,documentation"/>
<meta name="description" content="C++ source code API documentation for LLVM."/>
<title>LLVM: InstCombineLoadStoreAlloca.cpp File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head><body>
<p class="title">LLVM API Documentation</p>
<!-- Generated by Doxygen 1.8.6 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4d9c1978b5f07b6adb33a8870a898946.html">llvm3.6</a></li><li class="navelem"><a class="el" href="dir_5fa7ecd8d95c317b32615506984470d8.html">lib</a></li><li class="navelem"><a class="el" href="dir_ed2be07ed72f5c44fcceed313c4db32e.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_9756732a50db3e2140ab264ec925c677.html">InstCombine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">InstCombineLoadStoreAlloca.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="InstCombine_8h_source.html">InstCombine.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="Statistic_8h_source.html">llvm/ADT/Statistic.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="Loads_8h_source.html">llvm/Analysis/Loads.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="DataLayout_8h_source.html">llvm/IR/DataLayout.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="LLVMContext_8h_source.html">llvm/IR/LLVMContext.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="IntrinsicInst_8h_source.html">llvm/IR/IntrinsicInst.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="BasicBlockUtils_8h_source.html">llvm/Transforms/Utils/BasicBlockUtils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="Local_8h_source.html">llvm/Transforms/Utils/Local.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for InstCombineLoadStoreAlloca.cpp:</div>
<div class="dyncontent">
<div class="center"><img src="InstCombineLoadStoreAlloca_8cpp__incl.png" border="0" usemap="#InstCombineLoadStoreAlloca_8cpp" alt=""/></div>
<map name="InstCombineLoadStoreAlloca_8cpp" id="InstCombineLoadStoreAlloca_8cpp">
<area shape="rect" id="node2" href="InstCombine_8h.html" title="InstCombine.h" alt="" coords="1161,80,1276,107"/><area shape="rect" id="node34" href="DataLayout_8h.html" title="llvm/IR/DataLayout.h" alt="" coords="2782,415,2935,442"/><area shape="rect" id="node35" href="LLVMContext_8h.html" title="llvm/IR/LLVMContext.h" alt="" coords="2993,333,3156,360"/><area shape="rect" id="node40" href="IntrinsicInst_8h.html" title="llvm/IR/IntrinsicInst.h" alt="" coords="1143,251,1294,278"/><area shape="rect" id="node45" href="Statistic_8h.html" title="llvm/ADT/Statistic.h" alt="" coords="3213,497,3360,524"/><area shape="rect" id="node48" href="Loads_8h.html" title="llvm/Analysis/Loads.h" alt="" coords="2337,80,2495,107"/><area shape="rect" id="node49" href="BasicBlockUtils_8h.html" title="llvm/Transforms/Utils\l/BasicBlockUtils.h" alt="" coords="2464,155,2619,196"/><area shape="rect" id="node50" href="Local_8h.html" title="llvm/Transforms/Utils\l/Local.h" alt="" coords="2643,155,2797,196"/><area shape="rect" id="node3" href="InstCombineWorklist_8h.html" title="InstCombineWorklist.h" alt="" coords="269,415,432,442"/><area shape="rect" id="node13" href="AssumptionCache_8h.html" title="llvm/Analysis/Assumption\lCache.h" alt="" coords="529,244,713,285"/><area shape="rect" id="node24" href="Pass_8h.html" title="llvm/Pass.h" alt="" coords="2927,497,3020,524"/><area shape="rect" id="node25" href="TargetFolder_8h.html" title="llvm/Analysis/TargetFolder.h" alt="" coords="996,333,1193,360"/><area shape="rect" id="node28" href="ValueTracking_8h.html" title="llvm/Analysis/ValueTracking.h" alt="" coords="659,497,866,524"/><area shape="rect" id="node29" href="Dominators_8h.html" title="llvm/IR/Dominators.h" alt="" coords="1712,162,1867,189"/><area shape="rect" id="node33" href="IRBuilder_8h.html" title="llvm/IR/IRBuilder.h" alt="" coords="2205,251,2339,278"/><area shape="rect" id="node37" href="Operator_8h.html" title="llvm/IR/Operator.h" alt="" coords="2409,333,2543,360"/><area shape="rect" id="node39" href="InstVisitor_8h.html" title="llvm/IR/InstVisitor.h" alt="" coords="941,162,1083,189"/><area shape="rect" id="node43" href="PatternMatch_8h.html" title="llvm/IR/PatternMatch.h" alt="" coords="813,251,977,278"/><area shape="rect" id="node44" href="SimplifyLibCalls_8h.html" title="llvm/Transforms/Utils\l/SimplifyLibCalls.h" alt="" coords="1939,155,2093,196"/><area shape="rect" id="node4" href="DenseMap_8h.html" title="llvm/ADT/DenseMap.h" alt="" coords="1811,497,1973,524"/><area shape="rect" id="node5" href="Compiler_8h.html" title="llvm/Support/Compiler.h" alt="" coords="1901,721,2075,748"/><area shape="rect" id="node6" href="SmallVector_8h.html" title="llvm/ADT/SmallVector.h" alt="" coords="147,647,317,673"/><area shape="rect" id="node8" href="Instruction_8h.html" title="llvm/IR/Instruction.h" alt="" coords="1156,497,1303,524"/><area shape="rect" id="node10" href="Debug_8h.html" title="llvm/Support/Debug.h" alt="" coords="371,497,533,524"/><area shape="rect" id="node11" href="raw__ostream_8h.html" title="llvm/Support/raw_ostream.h" alt="" coords="520,572,723,599"/><area shape="rect" id="node9" href="ArrayRef_8h.html" title="llvm/ADT/ArrayRef.h" alt="" coords="957,572,1104,599"/><area shape="rect" id="node14" href="SmallSet_8h.html" title="llvm/ADT/SmallSet.h" alt="" coords="43,572,195,599"/><area shape="rect" id="node15" href="Function_8h.html" title="llvm/IR/Function.h" alt="" coords="1471,333,1603,360"/><area shape="rect" id="node18" href="Instructions_8h.html" title="llvm/IR/Instructions.h" alt="" coords="818,333,971,360"/><area shape="rect" id="node23" href="ValueHandle_8h.html" title="llvm/IR/ValueHandle.h" alt="" coords="1679,333,1838,360"/><area shape="rect" id="node16" href="BasicBlock_8h.html" title="llvm/IR/BasicBlock.h" alt="" coords="2053,415,2200,442"/><area shape="rect" id="node17" href="CBindingWrapping_8h.html" title="llvm/Support/CBindingWrapping.h" alt="" coords="2355,647,2589,673"/><area shape="rect" id="node19" href="DerivedTypes_8h.html" title="llvm/IR/DerivedTypes.h" alt="" coords="2149,497,2312,524"/><area shape="rect" id="node22" href="InstrTypes_8h.html" title="llvm/IR/InstrTypes.h" alt="" coords="1158,415,1301,442"/><area shape="rect" id="node20" href="Type_8h.html" title="llvm/IR/Type.h" alt="" coords="2437,572,2544,599"/><area shape="rect" id="node21" href="Core_8h.html" title="llvm&#45;c/Core.h" alt="" coords="2720,647,2827,673"/><area shape="rect" id="node26" href="ConstantFolding_8h.html" title="llvm/Analysis/ConstantFolding.h" alt="" coords="861,415,1083,442"/><area shape="rect" id="node27" href="Constants_8h.html" title="llvm/IR/Constants.h" alt="" coords="1325,415,1469,442"/><area shape="rect" id="node30" href="DepthFirstIterator_8h.html" title="llvm/ADT/DepthFirstIterator.h" alt="" coords="1687,251,1892,278"/><area shape="rect" id="node31" href="GraphTraits_8h.html" title="llvm/ADT/GraphTraits.h" alt="" coords="1862,333,2029,360"/><area shape="rect" id="node32" href="IR_2CFG_8h.html" title="llvm/IR/CFG.h" alt="" coords="1967,251,2073,278"/><area shape="rect" id="node36" href="Options_8h.html" title="llvm/Support/Options.h" alt="" coords="2589,415,2757,442"/><area shape="rect" id="node38" href="GetElementPtrTypeIterator_8h.html" title="llvm/IR/GetElementPtrType\lIterator.h" alt="" coords="2376,408,2565,449"/><area shape="rect" id="node41" href="Intrinsics_8h.html" title="llvm/IR/Intrinsics.h" alt="" coords="659,333,794,360"/><area shape="rect" id="node42" href="Metadata_8h.html" title="llvm/IR/Metadata.h" alt="" coords="1545,415,1685,442"/><area shape="rect" id="node46" href="Atomic_8h.html" title="llvm/Support/Atomic.h" alt="" coords="2923,572,3087,599"/><area shape="rect" id="node47" href="Valgrind_8h.html" title="llvm/Support/Valgrind.h" alt="" coords="3213,647,3384,673"/></map>
</div>
</div>
<p><a href="InstCombineLoadStoreAlloca_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;instcombine&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a625d5d622944254b7dbb70dd891e93c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a625d5d622944254b7dbb70dd891e93c2">STATISTIC</a> (NumDeadStore,&quot;Number of dead stores eliminated&quot;)</td></tr>
<tr class="separator:a625d5d622944254b7dbb70dd891e93c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6867ac335953146c3413957d424db70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#aa6867ac335953146c3413957d424db70">STATISTIC</a> (NumGlobalCopies,&quot;Number of allocas copied from constant global&quot;)</td></tr>
<tr class="separator:aa6867ac335953146c3413957d424db70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6752ff1d6270eefda9482e7694527c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a4d6752ff1d6270eefda9482e7694527c">pointsToConstantGlobal</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V)</td></tr>
<tr class="separator:a4d6752ff1d6270eefda9482e7694527c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3395c705cfba0619ab922fe3f6c316e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a3395c705cfba0619ab922fe3f6c316e8">isOnlyCopiedFromConstantGlobal</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1MemTransferInst.html">MemTransferInst</a> *&amp;TheCopy, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * &gt; &amp;ToDelete)</td></tr>
<tr class="separator:a3395c705cfba0619ab922fe3f6c316e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a19298a0f0e2e2d887daf95114fee50"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1MemTransferInst.html">MemTransferInst</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a2a19298a0f0e2e2d887daf95114fee50">isOnlyCopiedFromConstantGlobal</a> (<a class="el" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *AI, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * &gt; &amp;ToDelete)</td></tr>
<tr class="separator:a2a19298a0f0e2e2d887daf95114fee50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a4316098449ea508fe7a80ade3bb39"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#ae7a4316098449ea508fe7a80ade3bb39">combineLoadToNewType</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, <a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> &amp;<a class="el" href="LoopInfoImpl_8h.html#ab7b7f3fe4279386eae18cf924053d077">LI</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *NewTy)</td></tr>
<tr class="memdesc:ae7a4316098449ea508fe7a80ade3bb39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to combine a load to a new type.  <a href="#ae7a4316098449ea508fe7a80ade3bb39">More...</a><br/></td></tr>
<tr class="separator:ae7a4316098449ea508fe7a80ade3bb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac753d50af86892e5b9b69fff0266130d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#ac753d50af86892e5b9b69fff0266130d">combineLoadToOperationType</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, <a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> &amp;<a class="el" href="LoopInfoImpl_8h.html#ab7b7f3fe4279386eae18cf924053d077">LI</a>)</td></tr>
<tr class="memdesc:ac753d50af86892e5b9b69fff0266130d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine loads to match the type of value their uses after looking through intervening bitcasts.  <a href="#ac753d50af86892e5b9b69fff0266130d">More...</a><br/></td></tr>
<tr class="separator:ac753d50af86892e5b9b69fff0266130d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62939c73ba10f8a07bc139f53756f5a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a62939c73ba10f8a07bc139f53756f5a4">combineStoreToValueType</a> (<a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;IC, <a class="el" href="classllvm_1_1StoreInst.html">StoreInst</a> &amp;<a class="el" href="AMDGPUInstrInfo_8cpp.html#a716f5e42d0d8cc3686f761545c8c20bca6cbe5ff42f143903e1c67abf94613791">SI</a>)</td></tr>
<tr class="memdesc:a62939c73ba10f8a07bc139f53756f5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combine stores to match the type of value being stored.  <a href="#a62939c73ba10f8a07bc139f53756f5a4">More...</a><br/></td></tr>
<tr class="separator:a62939c73ba10f8a07bc139f53756f5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3265ae31efc424def9bd2a560a8a4c5a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="InstCombineLoadStoreAlloca_8cpp.html#a3265ae31efc424def9bd2a560a8a4c5a">equivalentAddressValues</a> (<a class="el" href="classllvm_1_1Value.html">Value</a> *A, <a class="el" href="classllvm_1_1Value.html">Value</a> *B)</td></tr>
<tr class="separator:a3265ae31efc424def9bd2a560a8a4c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;instcombine&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00024">24</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae7a4316098449ea508fe7a80ade3bb39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a>* combineLoadToNewType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> &amp;&#160;</td>
          <td class="paramname"><em>LI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>NewTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper to combine a load to a new type. </p>
<p>This just does the work of combining a load to a new type. It handles metadata, etc., and returns the new instruction. The <code>NewTy</code> should be the loaded <em>value</em> type. This will convert it to a pointer, cast the operand to that pointer type, load it, etc.</p>
<p>Note that this will create all of the instructions with whatever insert point the <code>InstCombiner</code> currently is using. </p>

<p>Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00303">303</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p>References <a class="el" href="InstCombine_8h_source.html#l00114">llvm::InstCombiner::Builder</a>, <a class="el" href="IRBuilder_8h_source.html#l00971">llvm::IRBuilder&lt; preserveNames, T, Inserter &gt;::CreateAlignedLoad()</a>, <a class="el" href="IRBuilder_8h_source.html#l01213">llvm::IRBuilder&lt; preserveNames, T, Inserter &gt;::CreateBitCast()</a>, <a class="el" href="Instructions_8h_source.html#l00214">llvm::LoadInst::getAlignment()</a>, <a class="el" href="Instruction_8h_source.html#l00160">llvm::Instruction::getAllMetadata()</a>, <a class="el" href="Value_8cpp_source.html#l00159">llvm::Value::getName()</a>, <a class="el" href="Instructions_8h_source.html#l00260">llvm::LoadInst::getPointerAddressSpace()</a>, <a class="el" href="Instructions_8h_source.html#l00255">llvm::LoadInst::getPointerOperand()</a>, <a class="el" href="Type_8cpp_source.html#l00759">llvm::Type::getPointerTo()</a>, <a class="el" href="ARMAsmParser_8cpp_source.html#l09194">ID</a>, <a class="el" href="Type_8h_source.html#l00217">llvm::Type::isPointerTy()</a>, <a class="el" href="LLVMContext_8h_source.html#l00057">llvm::LLVMContext::MD_alias_scope</a>, <a class="el" href="LLVMContext_8h_source.html#l00050">llvm::LLVMContext::MD_dbg</a>, <a class="el" href="LLVMContext_8h_source.html#l00053">llvm::LLVMContext::MD_fpmath</a>, <a class="el" href="LLVMContext_8h_source.html#l00056">llvm::LLVMContext::MD_invariant_load</a>, <a class="el" href="LLVMContext_8h_source.html#l00060">llvm::LLVMContext::MD_mem_parallel_loop_access</a>, <a class="el" href="LLVMContext_8h_source.html#l00058">llvm::LLVMContext::MD_noalias</a>, <a class="el" href="LLVMContext_8h_source.html#l00061">llvm::LLVMContext::MD_nonnull</a>, <a class="el" href="LLVMContext_8h_source.html#l00059">llvm::LLVMContext::MD_nontemporal</a>, <a class="el" href="LLVMContext_8h_source.html#l00052">llvm::LLVMContext::MD_prof</a>, <a class="el" href="LLVMContext_8h_source.html#l00054">llvm::LLVMContext::MD_range</a>, <a class="el" href="LLVMContext_8h_source.html#l00051">llvm::LLVMContext::MD_tbaa</a>, <a class="el" href="LLVMContext_8h_source.html#l00055">llvm::LLVMContext::MD_tbaa_struct</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, and <a class="el" href="Metadata_8cpp_source.html#l01078">llvm::Instruction::setMetadata()</a>.</p>

<p>Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00370">combineLoadToOperationType()</a>.</p>

</div>
</div>
<a class="anchor" id="ac753d50af86892e5b9b69fff0266130d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Instruction.html">Instruction</a>* combineLoadToOperationType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LoadInst.html">LoadInst</a> &amp;&#160;</td>
          <td class="paramname"><em>LI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine loads to match the type of value their uses after looking through intervening bitcasts. </p>
<p>The core idea here is that if the result of a load is used in an operation, we should load the type most conducive to that operation. For example, when loading an integer and converting that immediately to a pointer, we should instead directly load a pointer.</p>
<p>However, this routine must never change the width of a load or the number of loads as that would introduce a semantic change. This combine is expected to be a semantic no-op which just allows loads to more closely model the types of their consuming operations.</p>
<p>Currently, we also refuse to change the precise type used for an atomic load or a volatile load. This is debatable, and might be reasonable to change later. However, it is risky in case some backend or other part of LLVM is relying on the exact type loaded to select appropriate atomic operations. </p>

<p>Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00370">370</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p>References <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00303">combineLoadToNewType()</a>, <a class="el" href="InstCombine_8h_source.html#l00352">llvm::InstCombiner::EraseInstFromFunction()</a>, <a class="el" href="Value_8h_source.html#l00310">llvm::Value::hasOneUse()</a>, <a class="el" href="Instructions_8h_source.html#l00250">llvm::LoadInst::isSimple()</a>, <a class="el" href="LoopInfoImpl_8h_source.html#l00412">LI</a>, <a class="el" href="Value_8cpp_source.html#l00319">llvm::Value::replaceAllUsesWith()</a>, <a class="el" href="Value_8h_source.html#l00274">llvm::Value::use_empty()</a>, and <a class="el" href="Instruction_8h_source.html#l00051">llvm::Instruction::user_back()</a>.</p>

<p>Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00394">llvm::InstCombiner::visitLoadInst()</a>.</p>

</div>
</div>
<a class="anchor" id="a62939c73ba10f8a07bc139f53756f5a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> combineStoreToValueType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1InstCombiner.html">InstCombiner</a> &amp;&#160;</td>
          <td class="paramname"><em>IC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1StoreInst.html">StoreInst</a> &amp;&#160;</td>
          <td class="paramname"><em>SI</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combine stores to match the type of value being stored. </p>
<p>The core idea here is that the memory does not have any intrinsic type and where we can we should match the type of a store to the type of value being stored.</p>
<p>However, this routine must never change the width of a store or the number of stores as that would introduce a semantic change. This combine is expected to be a semantic no-op which just allows stores to more closely model the types of their incoming values.</p>
<p>Currently, we also refuse to change the precise type used for an atomic or volatile store. This is debatable, and might be reasonable to change later. However, it is risky in case some backend or other part of LLVM is relying on the exact type stored to select appropriate atomic operations.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the store was successfully combined away. This indicates the caller must erase the store instruction. We have to let the caller erase the store instruction sas otherwise there is no way to signal whether it was combined or not: IC.EraseInstFromFunction returns a null pointer. </dd></dl>

<p>Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00518">518</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p>References <a class="el" href="InstCombine_8h_source.html#l00114">llvm::InstCombiner::Builder</a>, <a class="el" href="IRBuilder_8h_source.html#l00988">llvm::IRBuilder&lt; preserveNames, T, Inserter &gt;::CreateAlignedStore()</a>, <a class="el" href="IRBuilder_8h_source.html#l01213">llvm::IRBuilder&lt; preserveNames, T, Inserter &gt;::CreateBitCast()</a>, <a class="el" href="Instructions_8h_source.html#l00333">llvm::StoreInst::getAlignment()</a>, <a class="el" href="Instruction_8h_source.html#l00160">llvm::Instruction::getAllMetadata()</a>, <a class="el" href="Instructions_8h_source.html#l00382">llvm::StoreInst::getPointerAddressSpace()</a>, <a class="el" href="Instructions_8h_source.html#l00377">llvm::StoreInst::getPointerOperand()</a>, <a class="el" href="Type_8cpp_source.html#l00759">llvm::Type::getPointerTo()</a>, <a class="el" href="Value_8h_source.html#l00222">llvm::Value::getType()</a>, <a class="el" href="Instructions_8h_source.html#l00374">llvm::StoreInst::getValueOperand()</a>, <a class="el" href="ARMAsmParser_8cpp_source.html#l09194">ID</a>, <a class="el" href="Instructions_8h_source.html#l00369">llvm::StoreInst::isSimple()</a>, <a class="el" href="LLVMContext_8h_source.html#l00057">llvm::LLVMContext::MD_alias_scope</a>, <a class="el" href="LLVMContext_8h_source.html#l00050">llvm::LLVMContext::MD_dbg</a>, <a class="el" href="LLVMContext_8h_source.html#l00053">llvm::LLVMContext::MD_fpmath</a>, <a class="el" href="LLVMContext_8h_source.html#l00056">llvm::LLVMContext::MD_invariant_load</a>, <a class="el" href="LLVMContext_8h_source.html#l00060">llvm::LLVMContext::MD_mem_parallel_loop_access</a>, <a class="el" href="LLVMContext_8h_source.html#l00058">llvm::LLVMContext::MD_noalias</a>, <a class="el" href="LLVMContext_8h_source.html#l00061">llvm::LLVMContext::MD_nonnull</a>, <a class="el" href="LLVMContext_8h_source.html#l00059">llvm::LLVMContext::MD_nontemporal</a>, <a class="el" href="LLVMContext_8h_source.html#l00052">llvm::LLVMContext::MD_prof</a>, <a class="el" href="LLVMContext_8h_source.html#l00054">llvm::LLVMContext::MD_range</a>, <a class="el" href="LLVMContext_8h_source.html#l00051">llvm::LLVMContext::MD_tbaa</a>, <a class="el" href="LLVMContext_8h_source.html#l00055">llvm::LLVMContext::MD_tbaa_struct</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, and <a class="el" href="Metadata_8cpp_source.html#l01078">llvm::Instruction::setMetadata()</a>.</p>

<p>Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00605">llvm::InstCombiner::visitStoreInst()</a>.</p>

</div>
</div>
<a class="anchor" id="a3265ae31efc424def9bd2a560a8a4c5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> equivalentAddressValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>equivalentAddressValues - Test if A and B will obviously have the same value. This includes recognizing that t0 and t1 will have the same value in code like this: t0 = getelementptr @a, 0, 3 store i32 0, i32* t0 t1 = getelementptr @a, 0, 3 t2 = load i32* t1 </p>

<p>Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00584">584</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p>Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00605">llvm::InstCombiner::visitStoreInst()</a>.</p>

</div>
</div>
<a class="anchor" id="a3395c705cfba0619ab922fe3f6c316e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isOnlyCopiedFromConstantGlobal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MemTransferInst.html">MemTransferInst</a> *&amp;&#160;</td>
          <td class="paramname"><em>TheCopy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ToDelete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>isOnlyCopiedFromConstantGlobal - Recursively walk the uses of a (derived) pointer to an alloca. Ignore any reads of the pointer, return false if we see any stores or other unknown uses. If we see pointer arithmetic, keep track of whether it moves the pointer (with IsOffset) but otherwise traverse the uses. If we see a memcpy/memmove that targets an unoffseted pointer to the alloca, and if the source pointer is a pointer to a constant global, we can optimize this. </p>

<p>Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00053">53</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p>References <a class="el" href="GlobalMerge_8cpp.html#a65c1240c404c646dd0e63fdcbf620730">assert()</a>, <a class="el" href="Casting_8h_source.html#l00285">llvm::dyn_cast()</a>, <a class="el" href="SmallVector_8h_source.html#l00056">llvm::SmallVectorBase::empty()</a>, <a class="el" href="IntrinsicInst_8h_source.html#l00246">llvm::MemTransferInst::getSource()</a>, <a class="el" href="MD5_8cpp_source.html#l00054">I</a>, <a class="el" href="IntrinsicInst_8h_source.html#l00154">llvm::MemIntrinsic::isVolatile()</a>, <a class="el" href="LoopInfoImpl_8h_source.html#l00412">LI</a>, <a class="el" href="Intrinsics_8h_source.html#l01338">llvm::Intrinsic::lifetime_end</a>, <a class="el" href="Intrinsics_8h_source.html#l01339">llvm::Intrinsic::lifetime_start</a>, <a class="el" href="AArch64BaseInfo_8h_source.html#l00197">llvm::AArch64CC::MI</a>, <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00032">pointsToConstantGlobal()</a>, <a class="el" href="SmallVector_8h_source.html#l00445">llvm::SmallVectorImpl&lt; T &gt;::pop_back_val()</a>, <a class="el" href="SmallVector_8h_source.html#l00221">llvm::SmallVectorTemplateBase&lt; T, isPodLike&lt; T &gt;::value &gt;::push_back()</a>, and <a class="el" href="SmallVector_8h_source.html#l00221">llvm::SmallVectorTemplateBase&lt; T, isPodLike &gt;::push_back()</a>.</p>

<p>Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00158">isOnlyCopiedFromConstantGlobal()</a>, and <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00166">llvm::InstCombiner::visitAllocaInst()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a19298a0f0e2e2d887daf95114fee50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1MemTransferInst.html">MemTransferInst</a>* isOnlyCopiedFromConstantGlobal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1AllocaInst.html">AllocaInst</a> *&#160;</td>
          <td class="paramname"><em>AI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Instruction.html">Instruction</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ToDelete</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>isOnlyCopiedFromConstantGlobal - Return true if the specified alloca is only modified by a copy from a constant global. If we can prove this, we can replace any uses of the alloca with uses of the global directly. </p>

<p>Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00158">158</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p>References <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00053">isOnlyCopiedFromConstantGlobal()</a>.</p>

</div>
</div>
<a class="anchor" id="a4d6752ff1d6270eefda9482e7694527c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> pointsToConstantGlobal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>pointsToConstantGlobal - Return true if V (possibly indirectly) points to some part of a constant global variable. This intentionally only accepts constant expressions because we can't rewrite arbitrary instructions. </p>

<p>Definition at line <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00032">32</a> of file <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html">InstCombineLoadStoreAlloca.cpp</a>.</p>

<p>Referenced by <a class="el" href="InstCombineLoadStoreAlloca_8cpp_source.html#l00053">isOnlyCopiedFromConstantGlobal()</a>.</p>

</div>
</div>
<a class="anchor" id="a625d5d622944254b7dbb70dd891e93c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumDeadStore&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of dead stores eliminated&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa6867ac335953146c3413957d424db70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumGlobalCopies&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of allocas copied from constant global&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<hr>
<p class="footer">
Generated on Tue Dec 8 2015 00:59:49 for <a href="http://llvm.org/">LLVM</a> by
<a href="http://www.doxygen.org"><img src="doxygen.png" alt="Doxygen"
align="middle" border="0"/>1.8.6</a><br>
Copyright &copy; 2003-2014 University of Illinois at Urbana-Champaign.
All Rights Reserved.</p>
<hr>
<!--#include virtual="/attrib.incl" -->
</body>
</html>
